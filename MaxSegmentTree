class SegmentTree{
public : 
    vector<int> seg;
    int sz;
    SegmentTree(int n){
        sz = n;
        seg.resize(4 * n + 5 , LLONG_MIN);
    }
    
    int merge(int a , int b){
        return max(a , b);
    }
    void build(int ind , int low , int high , vector<int> &arr){
        if(low == high){
            seg[ind] = arr[low];
            return ;
        }
        int mid = (low + high) / 2;
        build(2 * ind + 1 , low , mid , arr);
        build(2 * ind + 2 , mid + 1 , high , arr);
        seg[ind] = merge(seg[2 * ind + 1] , seg[2 * ind + 2]);
    }
    
    void getUpdated(int ind , int low , int high , int index , int val){
        if(low == high){
            seg[ind] = val;
            return ;
        }
        int mid = low + (high - low) / 2;
        if(index <= mid) getUpdated(2 * ind + 1 , low , mid , index , val);
        else getUpdated(2 * ind + 2 , mid + 1 , high , index , val);
        
        seg[ind] = merge(seg[2 * ind + 1] , seg[2 * ind + 2]);
    }
    
    int getVal(int ind , int low , int high , int l , int r){
        if(high < l || r < low) return LLONG_MIN;
        if(low >= l && high <= r) return seg[ind];
        
        int mid = (high + low) / 2;
        int left = getVal(2 * ind + 1 , low , mid , l , r);
        int right = getVal(2 * ind + 2 , mid + 1 , high , l , r);
        return merge(left , right);
    }
    
    int query(int l , int r){
        return getVal(0 , 0 , sz - 1 , l , r);
    }
    
    void make(vector<int> &arr){
        int n = arr.size();
        build(0 , 0 , n - 1 , arr);
    }
    void update(int ind , int val){
        int n = seg.size();
        getUpdated(0 , 0 , sz - 1 , ind , val);
    }
    
};
